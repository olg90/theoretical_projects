#%% Define the functions for fitting
import numpy as np
from matplotlib.pyplot import plot as pt
import matplotlib.pyplot as plt
from numpy.random import exponential, binomial, gamma
from numpy import exp
from numpy import sqrt as Sqrt
from numpy import log as Log
import pandas as pd

def simulate(vth, c, ci, f, fi, k,ki,pr, pri, M, Mi, tauv,tmax, delta_t, navgs):
    
    tavgs=[]
    cavgs=[]
    ratio = 0.3
    e=1e-6

    for _ in range(navgs):
        vlist=[]
        nlist=[]
        nilist=[]
        tlist=[]
        preliste=[]
        prelisti=[]
        postlist=[]
        n=0
        ni=0
        v=0
        tcurr=0
        timer = delta_t

        while tcurr < tmax:
            t0=exponential(1/(f+e)) # action potential
            t1=exponential(1/(fi+e))
            t2=exponential(1/(k*(M-n)+e))
            t3=exponential(1/(ki*(Mi-ni)+e))
            t4 = timer

            if t0<t1 and t0<t2 and t0<t3 and t0<t4: # AP occurrs
                b = binomial(n, pr)
                n=n-b
                v=v+c*b
                tmin = t0
                timer-=tmin
                preliste.append(tcurr+tmin)
                
            if t1<t0 and t1<t2 and t1<t3 and t1<t4: # AP occurrs
                bi = binomial(ni, pri)
                ni=ni-bi
                v=v-ci*bi
                tmin = t1
                timer-=tmin
                prelisti.append(tcurr+tmin)
                
            if t2<t0 and t2<t1 and t2<t3 and t2<t4: # AP occurrs
                n=n+1
                tmin=t2
                timer-=tmin
            if t3<t0 and t3<t1 and t3<t2 and t3<t4: # AP occurrs
                ni=ni+1
                tmin=t3
                timer-=tmin

            else:
                tmin=t4
                timer = delta_t
                if tcurr >= ratio*tmax:
                    vlist.append(v)
                    nlist.append(n)
                    nilist.append(ni)
                    tlist.append(tcurr)
                    
            tcurr += tmin
            if v>=vth:
                postlist.append(tcurr)
                if len(vlist)>0:
                    vlist[-1]=vth+0.01
                v=0

            # Update the continuous dynamics
            v += (-v / tauv) * tmin
    
        Tlist = np.diff(postlist)
        Tmean = np.mean(Tlist)
        CVT2=np.var(Tlist)/Tmean**2
        
        tavgs.append(Tmean)
        cavgs.append(CVT2)
    Tmean = np.mean(tavgs)
    CVT2 = np.mean(cavgs)
    return tlist, nlist, nilist, vlist, preliste, prelisti, postlist, Tmean, CVT2


f=100 # excitatory frequency
fi=50
pr=0.2
pri=0.2
M=100
Mi=100
k=5
ki=5
c=0.003
ci=0.003

tauv=0.05
vth=0.02 # Threshold value

tmax = 20 # <-------------- TMAX
delta_t = 0.001
navgs = 1

# =============================================================================
# tlist, nlist, nilist, vlist, preliste, prelisti, postlist, Tmean, CVT2 = \
#     simulate(vth, c, ci, f, fi, k, ki, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)
# fs=15
# plt.subplot(2,1,1)
# plt.step(tlist, nlist, label='n', where='post')
# plt.step(tlist, nilist, label='ni', where='post')
# # plt.ylim([np.min([nlist, nilist])-10, np.max([nlist, nilist])+10])
# # =============================================================================
# # for x in preliste[2:]:
# #     plt.axvline(x, color='r', alpha=0.4)
# # for y in prelisti[2:]:
# #     plt.axvline(y, color='b', alpha=0.4)
# # =============================================================================
# plt.tick_params(axis='both', labelsize=fs)
# plt.xticks([])
# plt.legend()
# plt.subplot(2,1,2)
# plt.plot(tlist, np.array(vlist))
# plt.plot(tlist, vth*np.ones(len(tlist)), color='k')
# plt.tick_params(axis='both', labelsize=fs)
# plt.xlabel('Time (sec)', fontsize=fs)
# # plt.ylim([np.min(vlist)-0.005, vth+0.02])
# plt.show()
# #%%
# =============================================================================

#% Vary parameters
xlist = np.linspace(0.001,0.2,100)
Fout=np.zeros(len(xlist))
cv2=np.zeros_like(Fout)
for i, x in enumerate(xlist):
    print(i, len(xlist))
    tauv=x
    res=simulate(vth, c, ci, f, fi, k, ki, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)
    Fout[i]=1/res[7]
    cv2[i]=res[8]
    
plt.subplot(2,1,1)
plt.ylabel('Fout')
plt.plot(xlist, Fout)
plt.subplot(2,1,2)
plt.ylabel('CV2')
plt.plot(xlist*1e3, cv2)
plt.xlabel('Time constant (ms)')
plt.show()


#%%  Check for three different fis for tauv

f=100 # excitatory frequency
fi=50
pr=0.2
pri=0.2
M=100
Mi=100
k=5
ki=5
c=0.003
ci=0.003

tauv=0.05
vth=0.02 # Threshold value

tmax = 30 # <-------------- TMAX
delta_t = 0.001
navgs = 1

xlist = np.linspace(0.001, 0.2, 100)
fi_list = [0, 25, 50, 100]  # inhibitory frequencies to test

for j, fi_val in enumerate(fi_list):
    Fout = np.zeros(len(xlist))
    cv2 = np.zeros_like(Fout)
    
    for i, x in enumerate(xlist):
        print(i, len(xlist), j, len(fi_list))
        tauv = x
        res = simulate(vth, c, ci, f, fi_val, k, ki, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)
        Fout[i] = 1 / res[7]
        cv2[i] = res[8]
    
    # Plot Fout
    plt.subplot(2, 1, 1)
    plt.plot(xlist*1e3, Fout, label=f'fi={fi_val}')
    plt.ylabel('Fout')
    
    # Plot CV2
    plt.subplot(2, 1, 2)
    plt.plot(xlist*1e3, cv2, label=f'fi={fi_val}')
    plt.ylabel('CV2')
    plt.xlabel('Time constant (ms)')

plt.subplot(2, 1, 1)
plt.legend()
plt.subplot(2, 1, 2)
plt.legend()
plt.tight_layout()
plt.show()


#%% Heatmap

# Heammap generation
flist = np.linspace(0,100,20)
filist=np.linspace(0,100,20)
Fout=np.zeros((len(flist), len(filist)))
cv2=np.zeros_like(Fout)
for i, f in enumerate(flist):
    for j, fi in enumerate(filist):
        print(i,j)
        res=simulate(vth, c, ci, f, fi, k, ki, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)
        Fout[i,j]=1/res[7]
        cv2[i,j]=res[8]

#%% heatmap plot
        
fig, ax = plt.subplots(1, 2, figsize=(10, 4))
extent = [filist[0], filist[-1], flist[0], flist[-1]]

# First plot with its own color scale
im0 = ax[0].imshow(Fout, origin='lower', extent=extent, aspect='auto',
                   vmin=np.nanmin(Fout), vmax=np.nanmax(Fout))
ax[0].set_title('Fout')
ax[0].set_xlabel('Inhibitory input frequency (Hz)')
ax[0].set_ylabel('Excitatory input frequency (Hz)')
fig.colorbar(im0, ax=ax[0], shrink=1.0, aspect=40, pad=0.02)

# Second plot with its own color scale
im1 = ax[1].imshow(cv2, origin='lower', extent=extent, aspect='auto',
                   vmin=np.nanmin(cv2), vmax=np.nanmax(cv2))
ax[1].set_title('Noise')
ax[1].set_xlabel('Inhibitory input frequency (Hz)')
ax[1].set_yticks([])
fig.colorbar(im1, ax=ax[1], shrink=1.0, aspect=40, pad=0.02)

plt.tight_layout()
plt.show()


#%% contour plots
        
X, Y = np.meshgrid(filist, flist)

fig, ax = plt.subplots(1, 2, figsize=(10, 4))

lvlf=20
lvlc=20

# First contour plot
c0 = ax[0].contourf(X, Y, Fout, levels=lvlf, cmap='viridis')
ax[0].set_title('Fout')
ax[0].set_xlabel('Inhibitory input frequency (Hz)')
ax[0].set_ylabel('Excitatory input frequency (Hz)')
fig.colorbar(c0, ax=ax[0], shrink=1.0, aspect=40, pad=0.02)

# Second contour plot
c1 = ax[1].contourf(X, Y, cv2, levels=lvlc, cmap='viridis')
ax[1].set_title('Noise')
ax[1].set_xlabel('Inhibitory input frequency (Hz)')
ax[1].set_yticks([])
fig.colorbar(c1, ax=ax[1], shrink=1.0, aspect=40, pad=0.02)

plt.tight_layout()
plt.show()

#%% add numbers

fig, ax = plt.subplots(1, 2, figsize=(10, 4))

ny, nx = Fout.shape  # rows, columns

# First plot: Fout
im0 = ax[0].imshow(Fout, origin='lower', aspect='equal',
                   vmin=np.nanmin(Fout), vmax=np.nanmax(Fout))
ax[0].set_title('Fout')
fig.colorbar(im0, ax=ax[0], shrink=1.0, aspect=40, pad=0.02)

for i in range(ny):
    for j in range(nx):
        val = Fout[i, j]
        if not np.isnan(val):
            ax[0].text(j, i, f"{int(round(val))}", ha='center', va='center', color='white', fontsize=8)

# Second plot: CV (multiply by 100)
im1 = ax[1].imshow(cv2, origin='lower', aspect='equal',
                   vmin=np.nanmin(cv2), vmax=np.nanmax(cv2))
ax[1].set_title('Noise')
fig.colorbar(im1, ax=ax[1], shrink=1.0, aspect=40, pad=0.02)

for i in range(ny):
    for j in range(nx):
        val = cv2[i, j]
        if not np.isnan(val):
            ax[1].text(j, i, f"{int(round(val*100))}", ha='center', va='center', color='white', fontsize=8)

plt.tight_layout()
plt.show()


#%% contour + numbers

fig, ax = plt.subplots(1, 2, figsize=(10, 4))

ny, nx = Fout.shape  # rows, columns
X, Y = np.meshgrid(np.arange(nx), np.arange(ny))  # pixel coordinates for centering

lvlf=20
lvlc=20


# First plot: Fout contour
c0 = ax[0].contourf(X, Y, Fout, levels=lvlf, origin='lower', cmap='viridis')
ax[0].set_title('Fout')
fig.colorbar(c0, ax=ax[0], shrink=1.0, aspect=40, pad=0.02)

# Overlay numbers
for i in range(ny):
    for j in range(nx):
        val = Fout[i, j]
        if not np.isnan(val):
            ax[0].text(j, i, f"{int(round(val))}", ha='center', va='center', color='white', fontsize=8)

# Second plot: CV contour (multiply by 100)
c1 = ax[1].contourf(X, Y, cv2, levels=lvlc, origin='lower', cmap='viridis')
ax[1].set_title('Noise')
fig.colorbar(c1, ax=ax[1], shrink=1.0, aspect=40, pad=0.02)

# Overlay numbers
for i in range(ny):
    for j in range(nx):
        val = cv2[i, j]
        if not np.isnan(val):
            ax[1].text(j, i, f"{int(round(val*100))}", ha='center', va='center', color='white', fontsize=8)

plt.tight_layout()
plt.show()
