#%% Define the functions for fitting
import numpy as np
from matplotlib.pyplot import plot as pt
import matplotlib.pyplot as plt
from numpy.random import exponential, binomial, gamma, poisson
from numpy import exp
from numpy import sqrt as Sqrt
from numpy import log as Log
import pandas as pd

def sim(vth, c, ci, f, fi, k,ki,pr, pri, M, Mi, tauv,tmax, delta_t, navgs):

    tavgs=[]
    cavgs=[]
    vavgs=[]
    vcv2=[]
    ratio = 0.3
    e=1e-6
    beav=[] # mean num bursts
    biav=[]
    neblistav=[] # num bursts until AP
    niblistav=[]

    for _ in range(navgs):
        vlist=[]
        nlist=[]
        nilist=[]
        tlist=[]
        preliste=[]
        prelisti=[]
        postlist=[]
        belist=[]
        bilist=[]
        nebursts=0
        nibursts=0
        neblist=[]
        niblist=[]
        n=0
        ni=0
        v=0
        tcurr=0
        timer = delta_t

        while tcurr < tmax:
            t0=exponential(1/(f+e)) # action potential
            t1=exponential(1/(fi+e))
            t2=exponential(1/(k*(M-n)+e))
            t3=exponential(1/(ki*(Mi-ni)+e))
            t4 = timer

            if t0<t1 and t0<t2 and t0<t3 and t0<t4: # AP occurrs
                b = binomial(n, pr)
                belist.append(b)
                n=n-b
                v=v+c*b
                tmin = t0
                timer-=tmin
                preliste.append(tcurr+tmin)
                nebursts+=1
                
                
            if t1<t0 and t1<t2 and t1<t3 and t1<t4: # AP occurrs
                bi = binomial(ni, pri)
                bilist.append(bi)
                ni=ni-bi
                v=v-ci*bi
                tmin = t1
                timer-=tmin
                prelisti.append(tcurr+tmin)
                nibursts+=1
                
                
            if t2<t0 and t2<t1 and t2<t3 and t2<t4: # AP occurrs
                n=n+1
                tmin=t2
                timer-=tmin
            if t3<t0 and t3<t1 and t3<t2 and t3<t4: # AP occurrs
                ni=ni+1
                tmin=t3
                timer-=tmin

            else:
                tmin=t4
                timer = delta_t
                if tcurr >= ratio*tmax:
                    vlist.append(v)
                    nlist.append(n)
                    nilist.append(ni)
                    tlist.append(tcurr)
                    
            tcurr += tmin
            if v>=vth:
                postlist.append(tcurr)
                if len(vlist)>0:
                    vlist[-1]=vth+0.01
                v=0
                neblist.append(nebursts)
                niblist.append(nibursts)
                nebursts=0
                nibursts=0

            # Update the continuous dynamics
            if tauv != np.inf:
                v += (-v / tauv) * tmin
                
        Tlist = np.diff(postlist)
        Tmean = np.mean(Tlist)
        CVT2=np.var(Tlist)/Tmean**2
        
        vavgs.append(np.mean(vlist))
        vcv2.append(np.var(vlist)/np.mean(vlist)**2)
        
        tavgs.append(Tmean)
        cavgs.append(CVT2)
        beav.append(np.mean(belist))
        biav.append(np.mean(bilist))
        neblistav.append(np.mean(neblist))
        niblistav.append(np.mean(niblist))
        
    Tmean = np.mean(tavgs)
    CVT2 = np.mean(cavgs)
    beav=np.mean(beav)
    biav=np.mean(biav)
    neblistav=np.mean(neblistav)
    niblistav=np.mean(niblistav)
    
    vavgs=np.mean(vavgs)
    vcv2=np.mean(vcv2)
    
    #         0     1     2          3      4         5           6       7
    return tlist, nlist, nilist, vlist, preliste, prelisti, postlist, Tmean, \
        CVT2, beav, biav, neblistav, niblistav, vavgs, vcv2
        #8     9      10      11          12     13     14

def simiid(vth, btype, lam, lami, c, ci, f, fi, pr, pri, M, Mi, tauv, tmax, delta_t, navgs):

    tavgs=[]
    cavgs=[]
    vavgs=[]
    vcv2=[]
    ratio = 0.3
    e=1e-6
    beav=[] # mean num bursts
    biav=[]
    neblistav=[] # num bursts until AP
    niblistav=[]

    for _ in range(navgs):
        vlist=[]
        tlist=[]
        preliste=[]
        prelisti=[]
        postlist=[]
        belist=[]
        bilist=[]
        nebursts=0
        nibursts=0
        neblist=[]
        niblist=[]
        n=0
        ni=0
        v=0
        tcurr=0
        timer = delta_t

        while tcurr < tmax:
            t0=exponential(1/(f+e)) # action potential
            t1=exponential(1/(fi+e))
            t2 = timer

            if t0<t1 and t0<t2: # AP occurrs
                if btype == 'bin':
                    b = binomial(M, pr)
                if btype == 'pois':
                    b = poisson(lam)
                belist.append(b)
                v=v+c*b
                tmin = t0
                timer-=tmin
                preliste.append(tcurr+tmin)
                nebursts+=1
                
                
            if t1<t0 and t1<t2: # AP occurrs
                if btype == 'bin':
                    bi = binomial(Mi, pri)
                if btype == 'pois':
                    bi = poisson(lami)
                bilist.append(bi)
                v=v-ci*bi
                tmin = t1
                timer-=tmin
                prelisti.append(tcurr+tmin)
                nibursts+=1
                
            else:
                tmin=t2
                timer = delta_t
                if tcurr >= ratio*tmax:
                    vlist.append(v)
                    tlist.append(tcurr)
                    
            tcurr += tmin
            if v>=vth:
                postlist.append(tcurr)
                if len(vlist)>0:
                    vlist[-1]=vth+0.01
                v=0
                neblist.append(nebursts)
                niblist.append(nibursts)
                nebursts=0
                nibursts=0
                
            # Update the continuous dynamics
            if tauv != np.inf:
                v += (-v / tauv) * tmin
    
        Tlist = np.diff(postlist)
        Tmean = np.mean(Tlist)
        CVT2=np.var(Tlist)/Tmean**2
        
        vavgs.append(np.mean(vlist))
        vcv2.append(np.var(vlist)/np.mean(vlist)**2)
        
        
        tavgs.append(Tmean)
        cavgs.append(CVT2)
        beav.append(np.mean(belist))
        biav.append(np.mean(bilist))
        neblistav.append(np.mean(neblist))
        niblistav.append(np.mean(niblist))
    Tmean = np.mean(tavgs)
    CVT2 = np.mean(cavgs)
    beav=np.mean(beav)
    biav=np.mean(biav)
    neblistav=np.mean(neblistav)
    niblistav=np.mean(niblistav)
    vavgs=np.mean(vavgs)
    vcv2=np.mean(vcv2)
    #        0        1     2        3           4         5     6     7
    return tlist, vlist, preliste, prelisti, postlist, Tmean, CVT2, beav, \
        biav, neblistav, niblistav, vavgs, vcv2
        # 8     9           10        11     12
        
def cv2vesicle(k, pr, tauv, f, M):
    return        (2*k**3*(-1 + pr - M*pr)*tauv + f**2*(-2 + pr)*pr**2*(1 + f*pr*tauv) - f*k*pr*(4 + pr*(-3 + 2*M + 2*f*tauv)) + k**2*(-2 + pr*(2 - 2*M + f*(-2 + pr)*tauv)))/(2.*f*k*M*pr*(-2*k + f*(-2 + pr)*pr)*tauv*(1 + k*tauv + f*pr*tauv))
def cv2iid(tauv,f):
    return 1/(2*f*tauv)

f=100 # excitatory frequency
fi=0
pr=0.04
pri=0.1
M=100
Mi=100
k=100
ki=5
c=0.001
ci=0.001

tauv=0.01 #0.05
vth=0.02 # Threshold value

tmax = 10 # <-------------- TMAX
delta_t = 0.001
navgs = 10

btype='bin' # bin - binomial, pois - poisson
lam=5
lami=5

# =============================================================================
# res=sim(vth, c, ci, f, fi, k, ki, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)
# resi=simiid(vth, btype, lam, lami, c, ci, f, fi, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)
# 
# =============================================================================
# print(res[7], res[8])
# print(resi[5], resi[6])

# =============================================================================
# # Plot trajectories
# tlist, nlist, nilist, vlist, preliste, prelisti, postlist, Tmean, CVT2, beav, biav, neblistav, niblistav, vavg, vcv2 = \
#     sim(vth, c, ci, f, fi, k, ki, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)
# fs=15
# plt.subplot(2,1,1)
# plt.step(tlist, nlist, label='n', where='post')
# # plt.step(tlist, nilist, label='ni', where='post')
# # plt.ylim([np.min([nlist, nilist])-10, np.max([nlist, nilist])+10])
# # =============================================================================
# # for x in preliste[2:]:
# #     plt.axvline(x, color='r', alpha=0.4)
# # for y in prelisti[2:]:
# #     plt.axvline(y, color='b', alpha=0.4)
# # =============================================================================
# plt.tick_params(axis='both', labelsize=fs)
# plt.xticks([])
# plt.legend()
# plt.subplot(2,1,2)
# plt.plot(tlist, np.array(vlist))
# plt.plot(tlist, vth*np.ones(len(tlist)), color='k')
# plt.tick_params(axis='both', labelsize=fs)
# plt.xlabel('Time (sec)', fontsize=fs)
# # plt.ylim([np.min(vlist)-0.005, vth+0.02])
# plt.show()
# 
# print(beav, biav)
# print(neblistav, niblistav)
# #%%
# =============================================================================

#% Vary parameters
xlist = np.linspace(1, 30,20)
vmean=np.zeros_like(xlist)
vcv2=np.zeros_like(xlist)
vmeaniid=np.zeros_like(xlist)
vcv2iid=np.zeros_like(xlist)
for i, x in enumerate(xlist):
    print(i, len(xlist))
    f=x
    res=sim(vth, c, ci, f, fi, k, ki, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)
    resi=simiid(vth, btype, lam, lami, c, ci, f, fi, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)

    vmean[i]=res[13]
    vcv2[i]=res[14]
    vmeaniid[i]=resi[11]
    vcv2iid[i]=resi[12]

fig,ax=plt.subplots(2,1)
# =============================================================================
# ax[0].plot(xlist, vmean, label='vmean')
# ax[0].plot(xlist, vcv2, label='vmeaniid')
# =============================================================================
ax[0].plot(xlist, vcv2, label='CVv2 vesc. sim')
ax[0].plot(xlist, cv2vesicle(k, pr, tauv, xlist, M), label='CVv2 vesc. eq')
ax[0].set_ylabel(f'CV$v^2$')
ax[0].set_xticks([])
# ax[0].set_ylim([0, 0.001])
ax[0].legend()
ax[1].plot(xlist, vcv2iid, label='CVv2iid sim')
ax[1].plot(xlist, cv2iid(tauv, xlist), label='CVv2iid eq')
ax[1].legend()
ax[1].set_xlabel('Input frequency')
ax[1].set_ylabel(f'CV$v^2$')
plt.show()



#%%  Check for three different fis for tauv


f=100 # excitatory frequency
fi=0
pr=0.02
pri=0.1
M=100
Mi=100
k=10
ki=5
c=0.001
ci=0.001

tauv=0.01 #0.05
vth=0.02 # Threshold value

tmax = 10 # <-------------- TMAX
delta_t = 0.001
navgs = 10

btype='bin' # bin - binomial, pois - poisson
lam=5
lami=5


xlist = np.linspace(0.001, 0.2, 40)
fi_list = [0, 10, 25, 100]  # inhibitory frequencies to test

Fout=[]
cv2=[]
for j, fi_val in enumerate(fi_list):
    Foutj = np.zeros(len(xlist))
    cv2j = np.zeros_like(Foutj)
    for i, x in enumerate(xlist):
        print(i, len(xlist), j, len(fi_list))
        tauv = x
        res = sim(vth, c, ci, f, fi_val, k, ki, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)
        Foutj[i] = 1 / res[7]
        cv2j[i] = res[8]
    Fout.append(Foutj)
    cv2.append(cv2j)
    
    
    #%%
# Plot Fout
fs=20
plt.subplot(2, 1, 1)
for i, F in enumerate(Fout):
    plt.plot(xlist*1e3, F, label='fi={}'.format(fi_list[i]))
plt.ylabel('Firing rate', fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)

# Plot CV2
plt.subplot(2, 1, 2)
for i, C in enumerate(cv2):
    plt.plot(xlist*1e3, C, label='fi={}'.format(fi_list[i]))
plt.ylabel('Noise in ISI', fontsize=fs)
plt.xlabel('Time constant, (ms)', fontsize=fs)
plt.tick_params(axis='both', labelsize=fs)


plt.subplot(2, 1, 1)
plt.legend()
plt.subplot(2, 1, 2)
plt.legend()
plt.tight_layout()
plt.show()


#%% Calculate the heatmap of Tmean and CV2 vs f and fi


f=100 # excitatory frequency
fi=0
pr=0.1
pri=0.1
M=100
Mi=100
k=10
ki=10
c=0.001
ci=0.001

tauv=0.01 #0.05
vth=0.02 # Threshold value

tmax = 20 # <-------------- TMAX
delta_t = 0.001
navgs = 100

btype='bin' # bin - binomial, pois - poisson
lam=5
lami=5

# Heammap generation
flist = np.linspace(0,100,40)
filist=np.linspace(0,100,40)
Fout=np.zeros((len(flist), len(filist)))
cv2=np.zeros_like(Fout)
for i, f in enumerate(flist):
    for j, fi in enumerate(filist):
        print(i, len(flist), j, len(flist))
        res=simiid(vth, btype, lam, lami, c, ci, f, fi, pr, pri, M, Mi, tauv, tmax, delta_t, navgs)
        Fout[i,j]=1/res[5]
        cv2[i,j]=res[6]

#%% plot the heatmap
        
green = 'lightgreen'  # define green once

fig, ax = plt.subplots(1, 2, figsize=(10, 4))
extent = [filist[0], filist[-1], flist[0], flist[-1]]
cmap = 'inferno'
fs = 15  # font size

# First plot (Fout)
im0 = ax[0].imshow(Fout, origin='lower', extent=extent, aspect='auto',
                   vmin=np.nanmin(Fout), vmax=np.nanmax(Fout), cmap=cmap)
ax[0].set_title('Output frequency', fontsize=fs)
ax[0].set_xlabel('                                                                    Inhibitory input frequency (Hz)', fontsize=fs)
ax[0].set_ylabel('Excitatory input frequency (Hz)', fontsize=fs)
cb0 = fig.colorbar(im0, ax=ax[0], shrink=1.0, aspect=40, pad=0.02)
cb0.ax.tick_params(labelsize=fs)
ax[0].tick_params(axis='both', labelsize=fs)

# Second plot (cv2)
im1 = ax[1].imshow(cv2, origin='lower', extent=extent, aspect='auto',
                   vmin=np.nanmin(cv2), vmax=np.nanmax(cv2), cmap=cmap)
ax[1].set_title('Noise in ISI', fontsize=fs)
ax[1].set_yticks([])  # hide y-ticks if desired
cb1 = fig.colorbar(im1, ax=ax[1], shrink=1.0, aspect=40, pad=0.02)
cb1.ax.tick_params(labelsize=fs)
ax[1].tick_params(axis='both', labelsize=fs)

# Overlay green line where cv2 = 1
X, Y = np.meshgrid(filist, flist)
contour = ax[1].contour(X, Y, cv2, levels=[1], colors=[green], linewidths=2)

# Add annotation with arrow pointing to the line
# Plot the text
ax[1].text(22, 28, r'$CV_T^2 = 1$', color=green, fontsize=fs+5)
# Plot an arrow pointing to the line
ax[1].arrow(22, 26, -3, -5, color=green, width=0.3, head_width=3.0, 
            head_length=3.0)


plt.tight_layout()
plt.show()



#%% contour plots
        
X, Y = np.meshgrid(filist, flist)

fig, ax = plt.subplots(1, 2, figsize=(10, 4))

lvlf=20
lvlc=20

fs=15

cmap='inferno'

# First contour plot
c0 = ax[0].contourf(X, Y, Fout, levels=lvlf, cmap=cmap)
ax[0].set_title('Output frequency', fontsize=fs)
ax[0].set_xlabel('Inhibitory input frequency (Hz)', fontsize=fs)
ax[0].set_ylabel('Excitatory input frequency (Hz)', fontsize=fs)
cb0 = fig.colorbar(c0, ax=ax[0], shrink=1.0, aspect=40, pad=0.02)
cb0.ax.tick_params(labelsize=fs)

# Second contour plot
c1 = ax[1].contourf(X, Y, cv2, levels=lvlc, cmap=cmap)
ax[1].set_title('Noise in ISI', fontsize=fs)
ax[1].set_xlabel('Inhibitory input frequency (Hz)', fontsize=fs)
ax[1].set_ylabel('Excitatory input frequency (Hz)', fontsize=fs)
cb1 = fig.colorbar(c1, ax=ax[1], shrink=1.0, aspect=40, pad=0.02)
cb1.ax.tick_params(labelsize=fs)

ax[0].tick_params(axis='both', labelsize=fs)
ax[1].tick_params(axis='both', labelsize=fs)

plt.tight_layout()
plt.show()


#%% add numbers

fig, ax = plt.subplots(1, 2, figsize=(10, 4))

ny, nx = Fout.shape  # rows, columns

# First plot: Fout
im0 = ax[0].imshow(Fout, origin='lower', aspect='equal',
                   vmin=np.nanmin(Fout), vmax=np.nanmax(Fout))
ax[0].set_title('Fout')
fig.colorbar(im0, ax=ax[0], shrink=1.0, aspect=40, pad=0.02)

for i in range(ny):
    for j in range(nx):
        val = Fout[i, j]
        if not np.isnan(val):
            ax[0].text(j, i, f"{int(round(val))}", ha='center', va='center', color='white', fontsize=8)

# Second plot: CV (multiply by 100)
im1 = ax[1].imshow(cv2, origin='lower', aspect='equal',
                   vmin=np.nanmin(cv2), vmax=np.nanmax(cv2))
ax[1].set_title('Noise')
fig.colorbar(im1, ax=ax[1], shrink=1.0, aspect=40, pad=0.02)

for i in range(ny):
    for j in range(nx):
        val = cv2[i, j]
        if not np.isnan(val):
            ax[1].text(j, i, f"{int(round(val*100))}", ha='center', va='center', color='white', fontsize=8)

plt.tight_layout()
plt.show()


#%% contour + numbers

fig, ax = plt.subplots(1, 2, figsize=(10, 4))

ny, nx = Fout.shape  # rows, columns
X, Y = np.meshgrid(np.arange(nx), np.arange(ny))  # pixel coordinates for centering

lvlf=20
lvlc=20


# First plot: Fout contour
c0 = ax[0].contourf(X, Y, Fout, levels=lvlf, origin='lower', cmap='viridis')
ax[0].set_title('Fout')
fig.colorbar(c0, ax=ax[0], shrink=1.0, aspect=40, pad=0.02)

# Overlay numbers
for i in range(ny):
    for j in range(nx):
        val = Fout[i, j]
        if not np.isnan(val):
            ax[0].text(j, i, f"{int(round(val))}", ha='center', va='center', color='white', fontsize=8)

# Second plot: CV contour (multiply by 100)
c1 = ax[1].contourf(X, Y, cv2, levels=lvlc, origin='lower', cmap='viridis')
ax[1].set_title('Noise')
fig.colorbar(c1, ax=ax[1], shrink=1.0, aspect=40, pad=0.02)

# Overlay numbers
for i in range(ny):
    for j in range(nx):
        val = cv2[i, j]
        if not np.isnan(val):
            ax[1].text(j, i, f"{int(round(val*100))}", ha='center', va='center', color='white', fontsize=8)

plt.tight_layout()
plt.show()
#%%  Probability calculations fixed threshold

import numpy as np
from scipy.special import gamma, gammaincc   # gamma function & upper incomplete gamma
from scipy.integrate import quad

# Parameters
fi      = 100.0
tauv    = 0.001
bimean  = 10.0
CVb2    = 1
bi2mean = (1+CVb2)*bimean**2

vmean = fi * tauv * bimean
CVv2  = bi2mean / (2 * bimean**2 * fi * tauv)

av   = 1 / CVv2
lamv = 1 / CVv2 / vmean

CVBe2  = 1.0
Bemean = 10.0

aBe   = 1 / CVBe2
lamBe = 1 / CVBe2 / Bemean

X = 0.02

# Integrand for v in [0, ∞)
def integrand(v):
    # 1 - Gamma[aBe, lamBe*(X + v)] / Gamma[aBe]
    # Gamma[aBe, z] is the upper incomplete gamma
    upper_inc = gamma(aBe) * gammaincc(aBe, lamBe * (X + v))
    return (1 - upper_inc / gamma(aBe)) * (lamv**av / gamma(av)) * v**(av - 1) * np.exp(-lamv * v)

# Numerical integration
prob, err = quad(integrand, 0, np.inf)
print("Probability =", prob)

# Simulate the Tout ~ Exp(f*finput)






#%% Probability calculations variable threshold

import numpy as np
from scipy.special import gamma, gammaincc   # complete gamma & regularized upper incomplete gamma
from scipy.integrate import quad

# Parameters
fi      = 100.0
tauv    = 0.001
bimean  = 10.0
bimean2 = 100.0

vmean = fi * tauv * bimean
CVb2    = 1
bi2mean = (1+CVb2)*bimean**2
CVv2  = bi2mean / (2 * bimean**2 * fi * tauv)

av   = 1 / CVv2
lamv = 1 / CVv2 / vmean

CVBe2  = 1.0
Bemean = 10.0

aBe   = 1 / CVBe2
lamBe = 1 / CVBe2 / Bemean

X0 = 0.02
y0 = 0.01
y1 = 0.001
v1 = -0.1

# Piecewise Y(v)
def Y(v):
    if v < -v1:
        return y0
    elif -v1 <= v <= 0:
        return y0 + (v + v1) * (y1 - y0) / v1
    else:
        return y1

# X(v) = X0 - Y(v)
def Xv(v):
    return X0 - Y(v)

# Integrand
def integrand(v):
    # upper incomplete gamma Γ(aBe, z) = Γ(aBe)*gammaincc(...)
    upper_inc = gamma(aBe) * gammaincc(aBe, lamBe * (Xv(v) + v))
    return (1 - upper_inc / gamma(aBe)) * (lamv**av / gamma(av)) * v**(av - 1) * np.exp(-lamv * v)

# Numerical integration
prob, err = quad(integrand, 0, np.inf)
print("Probability =", prob)

#%% Simulate the Tout ~ Exp(f*finput)


